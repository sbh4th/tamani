---
title: "Group-Time ATTs"
author: "Sam Harper"
date: "2021-11-02"
output:
  html_document: default
  pdf_document: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(here) 
library(tidyverse)
library(haven)
library(bacondecomp)
library(ggplot2)
library(fixest)
library(glue)
library(modelsummary)
library(TwoWayFEWeights)
library(kableExtra)
devtools::install_github("bcallaway11/did")
library(did)
```

# Standard Two-Way Fixed Effects 
First, let's read in the Stata dataset, and create a smaller version with just the variables of interest for looking at skilled birth attendance:
```{r d1, cache=TRUE}
d <- read_dta(here("data-clean", "hh_female_impact_rpt.dta")) %>%
    mutate(district = as_factor(hh1, levels = "labels"),
         time = as.numeric(delwave) + 1,
         sba_birth = as.numeric(sba_birth))

# restrict to variables for analysis
d_ind <- d %>% 
  select(district, sba_birth, txdel, time) %>%
  mutate(dist_id = as.numeric(district)) %>%
  drop_na() %>%
  group_by(district, dist_id) %>%
  mutate(group = min(if_else(txdel==1, time, 5)),
         g2 = if_else(group==2, 1, 0),
         g3 = if_else(group==3, 1, 0),
         g4 = if_else(group==4, 1, 0)) 

kable(head(d_ind)) %>%
  kable_styling()
```
Using this data, let's now run the standard TWFE analysis that is the workhorse of most DD applications with differential treatment timing. 

```{r twfei, cache=TRUE}
# Get TWFE coefficient from individual-level dataset
twfe <- fixest::feols(sba_birth ~ txdel | district + time, 
                      data = d,
                      weights = NULL, 
                      cluster = ~district)

twfe
```
Specifying this using an OLS model with standard errors clustered at the district level, we get a DD estimate that we would interpret as showing that the intervention increased the probability of skilled birth attendance by 6 percentage points (95% CI -0.7 to 12.7). 

Because the treatment is assigned at the cluster level and we aren't adjusting for any covariates, we can also analyze this at the cluster level. Next let's aggregate up to the district level. Here is a look at the dataset:
```{r d2, cache=TRUE}
d_sba <- d_ind %>%
  group_by(district, dist_id, time) %>%
  summarise(tsba = sum(sba_birth),
         tpop = n(),
         psba = tsba / tpop, # % SBA
         txdel = mean(txdel),
         group = mean(group))

d_sba %>%
  kbl(digits=3, escape = FALSE) %>%
  kable_styling()
```
You can see that we are aggregating up to the district level, and how we have the total population (`tpop`) and the total number of births with a skilled attendant (`tsba`), as well as the proportion by district. 

Now, we can also fit the TWFE model to this aggregate data, controlling for district fixed effects and survey wave. 
```{r twfea}
# Compare to pooled sample
twfep <- fixest::feols(psba ~ txdel | district + time, 
                      data = d_sba,
                      weights = ~tpop, 
                      cluster = ~district)

twfep
```

The estimates from these two models are identical (SEs are very minimally different), which is just to say that it is fine to work with the aggregate data to estimate the impact of the intervention (absent control for covariates):

```{r twfecomp, echo=FALSE}
# summary of TWFE models
models <- list("Individual" = twfe, "Aggregate" = twfep)
modelsummary(models, gof_omit = 'DF|Deviance|R2|AIC|BIC|Log.Lik')
```


## Callaway/Sant'Anna Approach
Okay so we have the traditional DD estimate of around a 6 percentage point increase in SBA. Now let's look at the Callaway-Sant'Anna DD estimate. Since the CS DD approach functions by aggregating different kinds of group-time DDs, we can also aggregate up to the group level, since we have 2 groups being treated at each wave post-baseline. Let's define a new variable `group` that indicates the time at which each group was *first* treated. So for Kaliua DC and 	
Urambo DC that were the first groups to be treated post-baseline (what we will call time=2), they are assigned a value of `group=2`, and so on for the other groups. Meanwhile, we are still aggregating up the number of births with SBA and the total population of each group.

```{r gt, message=FALSE}
# create group-time aggregate data
d_agg <- d_sba %>% group_by(group, time) %>%
  summarise(tsba = sum(tsba),
         tpop = sum(tpop),
         psba = tsba / tpop, # % SBA
         txdel = mean(txdel))

d_agg %>%
  kbl(digits=3, escape = FALSE) %>%
  kable_styling()
```

Now, just to get a look at what we are comparing when we run the group-time DDs, let's reshape this data to wide (just to see it):

```{r gtwide, message=FALSE, echo=F}
gt <- d_agg %>% select(group, time, psba, tpop) %>%
  pivot_wider(names_from = time, names_prefix = "t",
              values_from = c(psba, tpop))

gt %>%
  kbl(digits=3, escape = FALSE) %>%
  kable_styling()

gt <- d_agg %>% select(group, time, psba) %>%
  pivot_wider(names_from = time, names_prefix = "time",
              values_from = psba)
```

Okay, now let's estimate the impact using the CS DD method:
```{r csdid, message=FALSE, warning=FALSE, results=FALSE}
# Use not-yet-treated as comparison group
atts_cs <- did::att_gt(yname = "psba", # name of the LHS variable
                       tname = "time", # name of the time variable
                       idname = "dist_id", # name of the id variable
                       gname = "group", # name of the first treatment period
                       data = d_sba, # name of the data
                       xformla = NULL,
                       weightsname = "tpop",
                       est_method = "reg", # estimation method.
                       control_group = "notyettreated", # set the control group
                       bstrap = TRUE, # if TRUE compute boostrapped SE
                       biters = 1000, # number of boostrap interations
                       print_details = FALSE, # if TRUE, print detailed results
                       panel = FALSE) # panel or repeated cross-sectional
summary(atts_cs)
```

A summary of the estimates, SEs, and 95% CIs (based on 1000 bootstrapped replications) is below:
```{r csdidt, message=FALSE, echo=FALSE}
cstable <- tidy(atts_cs)
cstable %>% select(-point.conf.low, -point.conf.high) %>%
  kbl(digits=3, escape = FALSE) %>%
  kable_styling()
```

One thing that is immediately different from the TWFE method is that we get an entire suite of ATTs for each group and time period, which allows us to see: 

- heterogeneity across both groups treated at different times (e.g., the ATT in the first year of treatment is much larger for the group first treated at time=2 (ATT(2,2) = 0.01) relative to the estimated effect in the first year of treatment for the group first treated at time 4, i.e., ATT(4,4) = 0.13, though both estimates are imprecise); and 
- as well as different times for each treatment group, e.g.., the impact at time 3 for the group first treated at time 2 is 0.26 relative to 0.01 for the first year of treatment. 

Let's take a quick detour to understand where these estimates are coming from. 

## Group Time ATTs
The core of the CS estimator is the group-time ATT. They define groups based on when they were first treated and 

### Group 2
The basic idea of the group-time ATTs is to estimate a series of ATTs for each group $G$ that is treated at time $T$. So if we wanted to estimate the ATT at time=2 for the group that is first treated at time=2, we calculate the 'long' difference, i.e., post minus pre for the treated group ($G=2$) and the difference for all groups *not already treated* for the same period. Thus, the groups we are comparing to estimate ATT(2,2) are:
```{r gt22, echo=FALSE}
gt %>%
  kbl(digits=3, escape = FALSE) %>%
  kable_styling() %>%
  column_spec(2:3, color = "black", background = "red") %>%
  row_spec(2:4, background  = "lightgray") %>%
  column_spec(4:6, background = "white") %>%
  column_spec(1, background = "white") %>%
  kable_minimal() %>%
  footnote(general = "Red = treated, Gray = untreated")
```

If we take the population-weighted average SBA proportions for these two groups, we get

```{r att22, echo=FALSE}
d_agg %>% filter(time < 3) %>%
  mutate(g22 = if_else(group==2,1,0)) %>%
  group_by(g22, time) %>%
  summarise(tsba = sum(tsba),
            tpop = sum(tpop),
            psba = tsba / tpop) %>%
  select(g22, time, psba) %>%
  pivot_wider(names_from = time, values_from = psba,
              names_prefix = "time") %>%
  mutate(`Long diff` = `time2` - `time1`) %>%
  group_by() %>%
  mutate(ATT_2_2 = `Long diff` - lag(`Long diff`, default = NA)) %>%
  kable(digits=3) %>%
  column_spec(5, bold=TRUE) %>%
  kable_minimal()
```

Now, we can ask about how the effect in Group 2 changes with time after the intervention. The ATT(2,3) asks about the estimated treatment effect at time 3 ($t=3$) for the group that was first treated at time 2 ($g=2$). To get this estimate, we now create a similar 2x2 table but are using time 3 as the 'post' estimate. But note here that, since group 3 ($G=3$) is treated at time 3, we don't want to include it as a part of our control group, we that means we restrict our control comparison to only those groups that are **not** treated by time 3. So we are comparing:

```{r gt23}
gt %>%
  kbl(digits=3, escape = FALSE) %>%
  kable_styling() %>%
  column_spec(c(2,4), color = "black", background = "red") %>%
  row_spec(2, background = "white") %>%
  row_spec(3:4, background  = "lightgray") %>%
  column_spec(c(3,5,6), background = "white") %>%
  column_spec(1, background = "white") %>%
  kable_minimal() %>%
  footnote(general = "Red = treated, Gray = untreated")
```

And we get:
```{r att23}
d_agg %>% filter((time==1 | time==3) & group!=3) %>%
  mutate(g23 = if_else(group==2,1,0)) %>%
  group_by(g23, time) %>%
  summarise(tsba = sum(tsba),
            tpop = sum(tpop),
            psba = tsba / tpop) %>%
  select(g23, time, psba) %>%
  pivot_wider(names_from = time, values_from = psba,
              names_prefix = "time") %>%
  mutate(`Long diff` = `time3` - `time1`) %>%
  group_by() %>%
  mutate(ATT_2_3 = `Long diff` - lag(`Long diff`, default = NA)) %>%
  kable(digits=3) %>%
  column_spec(5, bold=TRUE) %>%
  kable_minimal()
```

We can of course extend our view of how the treatment effect evolves for Group 2 by calculating the effect of being treated at time 4 for the group that was first treated at time 2, i.e., ATT(2,4). This is comparing:
```{r gt24}
gt %>%
  kbl(digits=3, escape = FALSE) %>%
  kable_styling() %>%
  column_spec(c(2,5), color = "black", background = "red") %>%
  row_spec(2:3, background = "white") %>%
  row_spec(4, background  = "lightgray") %>%
  column_spec(6, background = "white") %>%
  column_spec(c(1,3,4), background = "white") %>%
  kable_minimal() %>%
  footnote(general = "Red = treated, Gray = untreated")
```

Note that the control group here also changes, since at $t=4$ group 4 has now been treated, so we exclude them from the control group for this comparison. And the estimate is:
```{r att24}
d_agg %>% filter((time==1 | time==4) & group!=3 & group!=4) %>%
  mutate(g24 = if_else(group==2,1,0)) %>%
  group_by(g24, time) %>%
  summarise(tsba = sum(tsba),
            tpop = sum(tpop),
            psba = tsba / tpop) %>%
  select(g24, time, psba) %>%
  pivot_wider(names_from = time, values_from = psba,
              names_prefix = "time") %>%
  mutate(`Long diff` = `time4` - `time1`) %>%
  group_by() %>%
  mutate(ATT_2_4 = `Long diff` - lag(`Long diff`, default = NA)) %>%
  kable(digits=3) %>%
  column_spec(5, bold=TRUE) %>%
  kable_minimal()
```

### Group 3
Now, what about the groups that are first treated at time 3, i.e., ($t=3$)? Since we actually have more than one pre-period for this group, we can also see whether there is some evidence of non-parallel trends by looking at, for example, the ATT(3,2), which is the effect of being treated at **time=2** for the group that is first treated at time 3. In essence, we are comparing the pre-intervention 'long difference' between $t=1$ and $t=2$ for the group eventually treated at time 3 with the same long difference among the controls:

```{r gt32}
gt %>%
  kbl(digits=3, escape = FALSE) %>%
  kable_styling() %>%
  column_spec(2:3, color = "black", background = "red") %>%
  row_spec(3:4, background  = "lightgray") %>%
  row_spec(1, background = "white") %>%
  column_spec(4:6, background = "white") %>%
  column_spec(1, background = "white") %>%
  kable_minimal() %>%
  footnote(general = "Red = treated, Gray = untreated")
```

The estimate of the ATT(3,2) is:
```{r att32}
d_agg %>% filter(time < 3 & group != 2) %>%
  mutate(g32 = if_else(group==3,1,0)) %>%
  group_by(g32, time) %>%
  summarise(tsba = sum(tsba),
            tpop = sum(tpop),
            psba = tsba / tpop) %>%
  select(g32, time, psba) %>%
  pivot_wider(names_from = time, values_from = psba,
              names_prefix = "time") %>%
  mutate(`Long diff` = `time2` - `time1`) %>%
  group_by() %>%
  mutate(ATT_3_2 = `Long diff` - lag(`Long diff`, default = NA)) %>%
  kable(digits=3) %>%
  column_spec(5, bold=TRUE) %>%
  kable_minimal()
```

Now for the treatment effect at time 3 for the groups first treated at time 3 we are comparing:
```{r gt33}
gt %>%
  kbl(digits=3, escape = FALSE) %>%
  kable_styling() %>%
  column_spec(3:4, color = "black", background = "red") %>%
  row_spec(3:4, background  = "lightgray") %>%
  row_spec(1, background = "white") %>%
  column_spec(c(1,2,5,6), background = "white") %>%
  column_spec(1, background = "white") %>%
  kable_minimal() %>%
  footnote(general = "Red = treated, Gray = untreated")
```

The estimate of the ATT(3,3) is:
```{r att33}
d_agg %>% filter(time >1 & time < 4 & group != 2) %>%
  mutate(g33 = if_else(group==3,1,0)) %>%
  group_by(g33, time) %>%
  summarise(tsba = sum(tsba),
            tpop = sum(tpop),
            psba = tsba / tpop) %>%
  select(g33, time, psba) %>%
  pivot_wider(names_from = time, values_from = psba,
              names_prefix = "time") %>%
  mutate(`Long diff` = `time3` - `time2`) %>%
  group_by() %>%
  mutate(ATT_3_3 = `Long diff` - lag(`Long diff`, default = NA)) %>%
  kable(digits=3) %>%
  column_spec(5, bold=TRUE) %>%
  kable_minimal()
```

The groups for comparison for the estimated treatment effect at time 4 for the groups first treated at time 3 now also need to exclude group 4, since it has received the treatment at time 4, but note also that the 'pre-intervention' period is still ($t=2$) since group 3 was actually treated at time 3. So, we care comparing:
```{r gt34}
gt %>%
  kbl(digits=3, escape = FALSE) %>%
  kable_styling() %>%
  column_spec(c(3,5), color = "black", background = "red") %>%
  row_spec(c(1,3), background = "white") %>%
  row_spec(4, background  = "lightgray") %>%
  column_spec(c(1,2,4,6), background = "white") %>%
  kable_minimal() %>%
  footnote(general = "Red = treated, Gray = untreated")
```

The estimate of the ATT(3,4) is:
```{r att34, message=FALSE}
d_agg %>% filter((time == 2 | time == 4) & (group == 3 | group == 5)) %>%
  mutate(g34 = if_else(group==3,1,0)) %>%
  group_by(g34, time) %>%
  summarise(tsba = sum(tsba),
            tpop = sum(tpop),
            psba = tsba / tpop) %>%
  select(g34, time, psba) %>%
  pivot_wider(names_from = time, values_from = psba,
              names_prefix = "time") %>%
  mutate(`Long diff` = `time4` - `time2`) %>%
  group_by() %>%
  mutate(ATT_3_4 = `Long diff` - lag(`Long diff`, default = NA)) %>%
  kable(digits=3) %>%
  column_spec(5, bold=TRUE) %>%
  kable_minimal()
```

### Group 4
Since we have untreated groups remaining at time 5, the last group we can estimate a 'clean' ATT for is Group 4. In this case, we also now have 2 pre-intervention periods we can use to assess the parallel trends assumption. For the time 2 periods before treatment starts for Group 4, we can compare the change in SBA between time 1 and time 2 for our treated group, i.e., the group first treated at time 4, and a control group. In this case the control group will only include Group 3 and Group 5, since Group 2 is treated at ($t=2$) and we have to exclude it. So our comparison groups are:
```{r gt42}
gt %>%
  kbl(digits=3, escape = FALSE) %>%
  kable_styling() %>%
  column_spec(c(2,3), color = "black", background = "red") %>%
  row_spec(1, background = "white") %>%
  row_spec(c(2,4), background = "lightgray") %>%
  column_spec(c(1,4,5,6), background = "white") %>%
  kable_minimal() %>%
  footnote(general = "Red = treated, Gray = untreated")
```

Again, taking the population-weighted estimate for the control group and the estimates for Group 4, we can calculate the ATT at time 2 for the group first treated at time 4, i.e., ATT(4,2):
```{r att42, message=FALSE}
d_agg %>% filter(time < 3 & group >= 3) %>%
  mutate(g42 = if_else(group==4,1,0)) %>%
  group_by(g42, time) %>%
  summarise(tsba = sum(tsba),
            tpop = sum(tpop),
            psba = tsba / tpop) %>%
  select(g42, time, psba) %>%
  pivot_wider(names_from = time, values_from = psba,
              names_prefix = "time") %>%
  mutate(`Long diff` = `time2` - `time1`) %>%
  group_by() %>%
  mutate(ATT_4_2 = `Long diff` - lag(`Long diff`, default = NA)) %>%
  kable(digits=3) %>%
  column_spec(5, bold=TRUE) %>%
  kable_minimal()
```
As you might expect, we now make the same progression for the addition ATTs for the the group first treated at time 4. First, for the next ATT for the pre-intervention period we want the treatment effect at time 3 for the group that is first treated at time 4. That means comparing only Groups 4 and 5 (since group 3 is treated at time 3, it has to be excluded from the control population):
```{r gt43}
gt %>%
  kbl(digits=3, escape = FALSE) %>%
  kable_styling() %>%
  column_spec(c(3,4), color = "black", background = "red") %>%
  row_spec(1:2, background = "white") %>%
  row_spec(4, background = "lightgray") %>%
  column_spec(c(1,2,5,6), background = "white") %>%
  kable_minimal() %>%
  footnote(general = "Red = treated, Gray = untreated")
```

And the resulting ATT(4,3) is:
```{r att43, message=FALSE}
d_agg %>% filter((time ==2 | time == 3) & group >= 4) %>%
  mutate(g43 = if_else(group==4,1,0)) %>%
  group_by(g43, time) %>%
  summarise(tsba = sum(tsba),
            tpop = sum(tpop),
            psba = tsba / tpop) %>%
  select(g43, time, psba) %>%
  pivot_wider(names_from = time, values_from = psba,
              names_prefix = "time") %>%
  mutate(`Long diff` = `time3` - `time2`) %>%
  group_by() %>%
  mutate(ATT_4_3 = `Long diff` - lag(`Long diff`, default = NA)) %>%
  kable(digits=3) %>%
  column_spec(5, bold=TRUE) %>%
  kable_minimal()
```
Finally, the last ATT we can estimate is the effect of being treated at time 4 for the group that is first treated at time 4. Again, we can only compare groups 4 and 5 here, since every other group has already been treated. So we are comparing:
```{r gt44}
gt %>%
  kbl(digits=3, escape = FALSE) %>%
  kable_styling() %>%
  column_spec(c(4,5), color = "black", background = "red") %>%
  row_spec(1:2, background = "white") %>%
  row_spec(4, background = "lightgray") %>%
  column_spec(c(1,2,3,6), background = "white") %>%
  kable_minimal() %>%
  footnote(general = "Red = treated, Gray = untreated")
```

And the resulting ATT(4,3) is:
```{r att44, message=FALSE}
d_agg %>% filter((time ==3 | time == 4) & group >= 4) %>%
  mutate(g44 = if_else(group==4,1,0)) %>%
  group_by(g44, time) %>%
  summarise(tsba = sum(tsba),
            tpop = sum(tpop),
            psba = tsba / tpop) %>%
  select(g44, time, psba) %>%
  pivot_wider(names_from = time, values_from = psba,
              names_prefix = "time") %>%
  mutate(`Long diff` = `time4` - `time3`) %>%
  group_by() %>%
  mutate(ATT_4_4 = `Long diff` - lag(`Long diff`, default = NA)) %>%
  kable(digits=3) %>%
  column_spec(5, bold=TRUE) %>%
  kable_minimal()
```

# Weighted ATTs
